<!DOCTYPE html>
<!--
  使い方 (Usage)

  * 現在、hirokws.comで一時的に公開中です。　

  - 通常モード: index.html をそのまま開く（クエリなし）
  - ハードモード: URL に ?hard（例: ?hard, ?hard=1, ?hard=true, ?hard=on）
    ・誤答して 0番に戻った直後のメッセージ: 何も表示しません
  - ソフトモード： URL に ?soft（例: ?soft, ?soft=1, ?soft=true, ?soft=on）
    ・正解して先へ進んだ場合でも、前回の異変を #message に表示します
  - 通常モード時の仕様:
    ・誤答して 0番に戻った直後に、原因（見逃し/誤報）を #message に表示します
  - デバッグ表示: URL に ?debug（例: ?debug, ?debug=1）でデバッグ UI を表示
  - シミュレーション: URL に ?sim=N（例: ?sim=1000, ?sim=5000）で乱数シミュレーションを実行
    ・実際のシャッフルアルゴリズムをN回実行し、末尾10個の出現頻度を分析
    ・結果はブラウザコンソール（F12）に詳細表示
    ・回数を指定しない場合（?sim）はデフォルト1000回
  - ゲームの起動は、ブラウザでファイルを開く（例: file:///index.html、もしくはファイルをd＆dする）
-->
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>８番通路</title>
    <style>
        /* --- Google Fonts --- */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@400;700&family=Orbitron:wght@400;700&display=swap');

        /* --- 基本設定 --- */
        :root {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --container-bg: rgba(30, 30, 30, 0.9);
            --border-color: #444;
            --title-color: #e53935;
            --message-color: #ffd700;
            --normal-light-color: #f0f0c0;
            --normal-sign-bg: #004d40;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Meiryo', 'Hiragino Kaku Gothic ProN', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            transition: background-color 1s ease, filter 1s ease;
        }

        .game-wrapper {
            position: relative;
            max-width: 800px;
            width: 90%;
            padding: 40px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--container-bg);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
            text-align: center;
            z-index: 2;
            overflow: hidden;
            transition: border-color 0.5s ease, border-radius 0.5s, background-color 0.5s, transform 0.5s, box-shadow 0.5s;
        }

        /* --- 視覚的オブジェクト --- */
        .ceiling-light {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%) perspective(100px) rotateX(45deg);
            width: 50%;
            height: 40px;
            background: linear-gradient(#222, #333);
            border: 2px solid #111;
            transition: width 0.5s, border-radius 0.5s;
        }

        .ceiling-light::after {
            content: '';
            display: block;
            width: 90%;
            height: 80%;
            margin: 5% auto;
            background-color: var(--normal-light-color);
            box-shadow: 0 0 15px 5px var(--normal-light-color);
            transition: background-color 0.5s, box-shadow 0.5s, animation-duration 0.5s;
            animation: light-hum 7s infinite alternate ease-in-out;
        }

        @keyframes light-hum {
            from {
                opacity: 0.95;
            }

            to {
                opacity: 1;
            }
        }

        .wall-sign {
            position: absolute;
            top: 40%;
            right: -20px;
            transform: translateY(-50%) perspective(200px) rotateY(-30deg);
            width: 100px;
            height: 150px;
            background-color: var(--normal-sign-bg);
            border: 5px solid #ccc;
            border-radius: 5px;
            box-shadow: -5px 5px 15px rgba(0, 0, 0, 0.5);
            transition: transform 0.5s, background-color 0.5s, box-shadow 0.5s, opacity 0.5s, border-style 0.5s;
        }

        .wall-sign::before {
            content: '非常口';
            color: white;
            font-size: 24px;
            font-weight: bold;
            writing-mode: vertical-rl;
            text-orientation: upright;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: content 0.3s, font-family 0.3s, color 0.3s;
        }

        .poster {
            position: absolute;
            top: 50%;
            left: -10px;
            transform: translateY(-50%) perspective(200px) rotateY(25deg);
            width: 90px;
            height: 130px;
            background-color: #f0ead6;
            border: 3px solid #333;
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.5);
            transition: transform 0.5s, background-color 0.5s, opacity 0.5s;
        }

        .poster::before {
            content: '安全第一';
            color: #333;
            font-size: 20px;
            font-weight: bold;
            writing-mode: vertical-rl;
            text-orientation: upright;
            white-space: nowrap;
            line-height: 1;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: content 0.3s;
        }

        .floor {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 25%;
            z-index: -1;
            background:
                linear-gradient(rgba(30, 30, 30, 0.9), rgba(30, 30, 30, 0.2)),
                repeating-linear-gradient(45deg, #444, #444 10px, #555 10px, #555 20px);
            transition: background 0.5s;
        }

        /* --- UI要素 --- */
        h1 {
            color: var(--title-color);
            font-family: 'Orbitron', sans-serif;
            font-size: 3em;
            font-weight: 700;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(229, 57, 53, 0.7);
            transition: font-weight 0.5s, color 0.5s, text-shadow 0.5s;
        }

        #description {
            font-size: 1.2em;
            line-height: 1.8;
            min-height: 150px;
            white-space: pre-wrap;
            margin-bottom: 30px;
            transition: color 0.5s, font-family 0.8s, letter-spacing 0.5s, text-align 0.5s, transform 0.5s;
        }

        .buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
            transition: flex-direction 0.5s;
        }

        button {
            padding: 15px 30px;
            font-size: 1.2em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #4CAF50;
            color: white;
            transition: background-color 0.3s, transform 0.1s, opacity 0.3s, color 0.3s, box-shadow 0.3s, border-radius 0.3s;
        }

        button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        button:hover:not(:disabled) {
            background-color: #45a049;
        }

        button:active:not(:disabled) {
            transform: scale(0.98);
        }

        #back-button {
            background-color: #f44336;
        }

        #back-button:hover:not(:disabled) {
            background-color: #da190b;
        }

        #message {
            margin-top: 20px;
            font-size: 1.2em;
            color: var(--message-color);
            font-weight: bold;
            height: 30px;
            transition: opacity 0.5s, color 0.5s, border 0.5s;
            box-sizing: border-box;
        }

        /* --- 暗転用オーバーレイ --- */
        #fade-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #000;
            opacity: 0;
            z-index: 9999;
            pointer-events: none;
            transition: opacity 1s ease-in-out;
        }

        #fade-overlay.is-active {
            opacity: 1;
            pointer-events: auto;
        }

        /* --- 異変適用時はトランジションを抑止（見破り防止） --- */
        #game-wrapper.no-transition,
        #game-wrapper.no-transition * {
            transition: none !important;
        }

        body.no-transition-filter {
            transition: none !important;
        }

        /* --- 追加オブジェクト --- */
        .puddle {
            position: absolute;
            bottom: 5%;
            left: 50%;
            width: 100px;
            height: 30px;
            background: rgba(80, 120, 150, 0.3);
            border-radius: 50%;
            transform: translateX(-50%) perspective(50px) rotateX(60deg);
            box-shadow: 0 0 10px rgba(80, 120, 150, 0.5);
            display: none;
        }

        .anomaly-puddle .puddle {
            display: block;
        }

        .crack {
            position: absolute;
            top: 20%;
            left: 10%;
            width: 5px;
            height: 150px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            transform: rotate(20deg);
            display: none;
        }

        .crack::after {
            content: '';
            position: absolute;
            top: 50px;
            left: -30px;
            width: 3px;
            height: 80px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 50%;
            transform: rotate(-40deg);
        }

        .anomaly-crack .crack {
            display: block;
        }

        /* --- デバッグモード用スタイル --- */
        #debug-toggle-btn {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            padding: 8px 12px;
            border: 1px solid #0f0;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            z-index: 10001;
            cursor: pointer;
            display: none;
        }

        #debug-toggle-btn:hover {
            background: rgba(0, 150, 0, 0.3);
        }

        #debug-info {
            position: fixed;
            bottom: 45px;
            left: 10px;
            background: rgba(0, 0, 0, 0.95);
            color: #0f0;
            padding: 15px;
            border: 1px solid #0f0;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            line-height: 1.5;
            z-index: 10000;
            text-align: left;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }

        #debug-info.hidden {
            display: none !important;
        }

        #debug-info h3 {
            margin: 0 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #0f0;
            color: #0f0;
            font-size: 14px;
        }

        #debug-info select,
        #debug-info button {
            margin-top: 10px;
            width: 100%;
            font-size: 11px;
        }

        #debug-info select {
            max-height: 200px;
        }

        /* --- 異変のスタイル --- */
        .anomaly-light-red .ceiling-light::after {
            background-color: #ff4d4d;
            box-shadow: 0 0 20px 10px #ff4d4d;
        }

        .anomaly-light-flicker .ceiling-light::after {
            animation: flicker 0.3s infinite alternate;
        }

        @keyframes flicker {
            0% {
                opacity: 1;
            }

            40% {
                opacity: 0.3;
            }

            100% {
                opacity: 0.8;
            }
        }

        .anomaly-light-off .ceiling-light::after {
            background-color: #333;
            box-shadow: none;
        }

        .anomaly-light-green .ceiling-light::after {
            background-color: #4caf50;
            box-shadow: 0 0 20px 10px #4caf50;
        }

        .anomaly-light-narrow .ceiling-light {
            width: 40%;
        }

        .anomaly-sign-crooked .wall-sign {
            transform: translateY(-50%) perspective(200px) rotateY(-30deg) rotateZ(-15deg);
        }

        .anomaly-sign-garbled .wall-sign::before {
            font-family: 'MS Mincho';
        }

        .anomaly-sign-shadow .wall-sign {
            box-shadow: -5px 5px 15px rgba(200, 0, 0, 0.5);
        }

        .anomaly-sign-blue .wall-sign {
            background-color: #1565c0;
        }

        .anomaly-sign-missing .wall-sign {
            opacity: 0;
        }

        .anomaly-sign-text-changed .wall-sign::before {
            content: '入口';
        }

        .anomaly-sign-dashed .wall-sign {
            border-style: dashed;
        }

        .anomaly-sign-text-yellow .wall-sign::before {
            color: yellow;
        }

        .anomaly-font-creepy #description {
            font-family: 'Noto Serif JP', serif;
            color: #bbb;
        }

        .anomaly-shake {
            animation: shake 5s infinite linear;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            10%,
            30%,
            50%,
            70%,
            90% {
                transform: translateX(-4px);
            }

            20%,
            40%,
            60%,
            80% {
                transform: translateX(4px);
            }
        }

        .anomaly-letter-spacing #description {
            letter-spacing: 0.1em;
        }

        .anomaly-title-weight h1 {
            font-weight: 400;
        }

        .anomaly-text-align-justify #description {
            text-align: justify;
        }

        .anomaly-border-radius {
            border-radius: 50px;
        }

        .anomaly-buttons-swapped .buttons {
            flex-direction: row-reverse;
        }

        .anomaly-text-color-strong {
            color: #f06292 !important;
        }

        .anomaly-title-color-strong {
            color: #ff5722 !important;
        }

        .anomaly-border-color-strong {
            border-color: #6a1b9a !important;
        }

        .anomaly-bg-strong {
            background-color: #0d47a1 !important;
        }

        .anomaly-wrapper-bg-strong {
            background-color: rgba(70, 20, 20, 0.9) !important;
        }

        .anomaly-puddle-green .puddle {
            display: block;
            background: rgba(50, 150, 50, 0.5);
            box-shadow: 0 0 15px rgba(50, 150, 50, 0.7);
        }

        .anomaly-crack-red .crack,
        .anomaly-crack-red .crack::after {
            display: block;
            background: rgba(255, 0, 0, 0.5);
        }

        .anomaly-floor-yellow .floor {
            background: linear-gradient(rgba(30, 30, 30, 0.9), rgba(30, 30, 30, 0.2)), repeating-linear-gradient(45deg, #FFD700, #FFD700 10px, #FFC107 10px, #FFC107 20px);
        }

        .anomaly-border-color-green {
            border-color: #4caf50 !important;
        }

        .anomaly-border-color-blue {
            border-color: #2196f3 !important;
        }

        .anomaly-floor-red .floor {
            background: linear-gradient(rgba(30, 30, 30, 0.2), rgba(30, 30, 30, 0.1)), repeating-linear-gradient(45deg, #b71c1c, #b71c1c 10px, #c62828 10px, #c62828 20px);
        }

        .anomaly-floor-blue .floor {
            background: linear-gradient(rgba(30, 30, 30, 0.2), rgba(30, 30, 30, 0.1)), repeating-linear-gradient(90deg, #1a237e, #1a237e 10px, #283593 10px, #283593 20px);
        }

        .anomaly-poster-upside-down .poster {
            transform: translateY(-50%) perspective(200px) rotateY(25deg) rotateZ(180deg);
        }

        .anomaly-poster-text-garbled .poster::before {
            content: '■■■■';
        }

        /* Mirror text on the right exit sign */
        .anomaly-sign-text-mirrored .wall-sign::before {
            transform: translate(-50%, -50%) scaleX(-1);
        }

        /* Mirror text on the left poster */
        .anomaly-poster-text-mirrored .poster::before {
            transform: translate(-50%, -50%) scaleX(-1);
        }

        .anomaly-sign-open .wall-sign {
            transform: translateY(-50%) perspective(200px) rotateY(-70deg);
        }

        .anomaly-sign-open .wall-sign::before {
            content: '';
        }

        .anomaly-sign-open .wall-sign::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }

        .anomaly-sign-peeking .wall-sign::after {
            content: '👀';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 30px;
        }

        .anomaly-buttons-black-text button {
            color: #000;
        }

        .anomaly-poster-missing .poster {
            opacity: 0;
        }

        .anomaly-poster-text-changed .poster::before {
            content: '危険';
        }

        .anomaly-poster-color-changed .poster {
            background-color: #add8e6;
        }

        /* Poster size variations */
        .anomaly-poster-bigger .poster {
            transform: translateY(-50%) perspective(200px) rotateY(25deg) scale(1.3);
        }

        .anomaly-poster-smaller .poster {
            transform: translateY(-50%) perspective(200px) rotateY(25deg) scale(0.7);
        }

        /* Eye on the poster (peeking style, same as sign) */
        .anomaly-poster-eye .poster::after {
            content: '👀';
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 40px;
            filter: drop-shadow(0 0 6px rgba(0, 0, 0, 0.7));
        }

        .anomaly-text-upside-down #description {
            transform: rotate(180deg);
        }

        .anomaly-text-mirrored #description {
            transform: scaleX(-1);
        }

        .anomaly-floor-angle-changed .floor {
            background: linear-gradient(rgba(30, 30, 30, 0.9), rgba(30, 30, 30, 0.2)), repeating-linear-gradient(135deg, #444, #444 10px, #555 10px, #555 20px);
        }

        .anomaly-floor-steeper-angle .floor {
            background: linear-gradient(rgba(30, 30, 30, 0.9), rgba(30, 30, 30, 0.2)),
                repeating-linear-gradient(60deg, #444, #444 10px, #555 10px, #555 20px);
        }

        .anomaly-floor-wider-stripes .floor {
            background: linear-gradient(rgba(30, 30, 30, 0.9), rgba(30, 30, 30, 0.2)),
                repeating-linear-gradient(45deg, #444, #444 10px, #555 10px, #555 25px);
        }

        .anomaly-puddle-red .puddle {
            display: block;
            background: rgba(150, 50, 50, 0.5);
            box-shadow: 0 0 15px rgba(150, 50, 50, 0.7);
        }

        .anomaly-title-shadow-green h1 {
            text-shadow: 0 0 15px #0f0;
        }

        .anomaly-buttons-glow button {
            box-shadow: 0 0 15px #fff;
        }


        .anomaly-wrapper-rotated {
            transform: rotate(-2deg);
        }

        .anomaly-message-border #message {
            border: 1px solid var(--message-color);
        }

        /* removed: fast flicker anomaly per request */

        .anomaly-buttons-square button {
            border-radius: 0;
        }

        .anomaly-buttons-logic-swapped #forward-button,
        .anomaly-buttons-logic-swapped #back-button {
            position: relative;
            color: transparent;
            /* Hide original text */
        }

        .anomaly-buttons-logic-swapped #forward-button::after {
            content: '戻る';
            /* "Back" text on the forward button */
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            color: #fff;
        }

        .anomaly-buttons-logic-swapped #back-button::after {
            content: '進む';
            /* "Forward" text on the back button */
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            color: #fff;
        }

        .anomaly-buttons-logic-swapped #forward-button,
        .anomaly-buttons-logic-swapped #back-button {
            position: relative;
            color: transparent;
            /* Hide original text */
        }

        .anomaly-buttons-logic-swapped #forward-button::after {
            content: '戻る';
            /* "Back" text on the forward button */
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            color: #fff;
        }

        .anomaly-buttons-logic-swapped #back-button::after {
            content: '進む';
            /* "Forward" text on the back button */
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            color: #fff;
        }

        /* --- Added anomalies (request) --- */
        /* 2. Forward button label becomes imperative "進め" */
        .anomaly-forward-imperative #forward-button {
            position: relative;
            color: transparent;
        }

        .anomaly-forward-imperative #forward-button::after {
            content: '進め';
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            color: #fff;
        }

        /* 3. Back button label becomes imperative "戻れ" */
        .anomaly-back-imperative #back-button {
            position: relative;
            color: transparent;
        }

        .anomaly-back-imperative #back-button::after {
            content: '戻れ';
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            color: #fff;
        }

        /* 4. Panties at bottom-right */
        #game-wrapper.anomaly-panties-br::after {
            content: '🩲';
            position: absolute;
            right: 8px;
            bottom: 6px;
            font-size: 28px;
            transform: rotate(15deg);
            filter: drop-shadow(2px 4px 3px rgba(0, 0, 0, 0.5)) brightness(0.7);
            pointer-events: none;
        }

        /* 5. Trunks at bottom-left */
        #game-wrapper.anomaly-trunks-bl::before {
            content: '🩳';
            position: absolute;
            left: 8px;
            bottom: 6px;
            font-size: 28px;
            transform: rotate(-15deg);
            filter: drop-shadow(2px 4px 3px rgba(0, 0, 0, 0.5)) brightness(0.7);
            pointer-events: none;
        }

        /* Anomaly: Hand from floor */
        #game-wrapper.anomaly-floor-hand::after {
            content: '✋';
            position: absolute;
            bottom: 5%;
            right: 15%;
            font-size: 50px;
            transform: rotate(-30deg);
            z-index: 0;
        }

        /* Anomaly: Shadow hand from floor */
        #game-wrapper.anomaly-floor-shadow-hand::after {
            content: '✋';
            position: absolute;
            bottom: 5%;
            right: 15%;
            font-size: 60px;
            color: #000;
            opacity: 0.6;
            transform: rotate(-30deg);
            filter: blur(3px);
            z-index: 0;
        }

        /* Anomaly: Bamboo shoot from floor */
        #game-wrapper.anomaly-floor-bamboo::before {
            content: '▲';
            position: absolute;
            bottom: 5%;
            left: 15%;
            font-size: 50px;
            color: #D2B48C;
            /* Light brown */
            transform: scaleY(1.5);
            filter: blur(1px);
            z-index: 0;
        }

        /* Anomaly: Mushroom from floor */
        #game-wrapper.anomaly-floor-mushroom::before {
            content: '🍄‍🟫';
            position: absolute;
            bottom: 5%;
            left: 15%;
            font-size: 50px;
            z-index: 0;
        }

        /* Anomaly: Grass from floor */
        #game-wrapper.anomaly-floor-grass::before {
            content: '🌿';
            position: absolute;
            bottom: 5%;
            left: 15%;
            font-size: 50px;
            z-index: 0;
        }

        /* Anomaly: W from floor */
        #game-wrapper.anomaly-floor-w::before {
            content: 'W';
            position: absolute;
            bottom: 5%;
            left: 15%;
            font-size: 50px;
            font-weight: bold;
            color: #fff;
            z-index: 0;
        }

        /* 6. Poster text "安全弟一" */
        .anomaly-poster-safety-brother .poster::before {
            content: '安全弟一';
        }

        /* Poster text "安全安心" */
        .anomaly-poster-safety-anshin .poster::before {
            content: '安全安心';
        }

        /* 7. (Removed) Message ellipsis color black — deleted per request */

        /* 8. Exit sign position higher/lower */
        .anomaly-sign-higher .wall-sign {
            top: 30%;
        }

        .anomaly-sign-lower .wall-sign {
            top: 50%;
        }

        /* 9. Poster position higher/lower */
        .anomaly-poster-higher .poster {
            top: 40%;
        }

        .anomaly-poster-lower .poster {
            top: 60%;
        }

        /* 10. Passage title slightly lower */
        .anomaly-passage-title-lower #passage-title {
            transform: translateY(8px);
        }

        /* 11. Ceiling light stronger blur */
        .anomaly-light-blur-stronger .ceiling-light::after {
            box-shadow: 0 0 22px 8px var(--normal-light-color);
        }

        /* 12. Buttons avoid cursor (JS-driven; optional easing here) */
        .anomaly-buttons-avoid-cursor .buttons button {
            will-change: transform;
        }

        /* New: cursor appears faint (light, semi-transparent) */
        .anomaly-cursor-faint#game-wrapper,
        .anomaly-cursor-faint#game-wrapper * {
            cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><circle cx='8' cy='8' r='6' fill='%23fff' fill-opacity='0.35' stroke='%23fff' stroke-opacity='0.35'/></svg>") 8 8, default;
        }

        /* New: dim the game when cursor leaves wrapper (active only when anomaly on) */
        .anomaly-dim-on-leave#game-wrapper.is-dimmed {
            filter: brightness(0.6) contrast(0.95);
        }

        /* New: cursor trail dots */
        .anomaly-cursor-trail .cursor-trail-dot {
            position: absolute;
            left: 0;
            top: 0;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.35);
            transform: translate(-50%, -50%) scale(1);
            pointer-events: none;
            filter: blur(0.4px);
            animation: trailFade 0.6s ease-out forwards;
            z-index: 5;
        }

        @keyframes trailFade {
            from {
                opacity: 0.35;
                transform: translate(-50%, -50%) scale(1);
            }

            to {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.8);
            }
        }

        body.anomaly-body-grayscale {
            filter: grayscale(100%);
        }

        body.anomaly-body-sepia {
            filter: sepia(100%);
        }

        body.anomaly-body-invert {
            filter: invert(100%);
        }

        body.anomaly-body-hue-rotate {
            filter: hue-rotate(180deg);
        }

        body.anomaly-body-blur {
            filter: blur(3px);
        }

        body.anomaly-body-contrast {
            filter: contrast(200%);
        }

        /* Background silhouette (bring above wrapper for visibility) */
        body.anomaly-body-silhouette::before {
            content: '👤';
            position: fixed;
            left: 50%;
            top: 35%;
            transform: translate(-50%, -50%);
            font-size: 220px;
            color: rgba(255, 255, 255, 0.18);
            text-shadow: 0 0 12px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            z-index: 3;
            /* above wrapper (z-index:2), below fade/debug */
        }

        /* Body anomaly: small heart at browser top-left */
        body.anomaly-body-heart-topleft::before {
            content: '❤';
            position: fixed;
            top: 8px;
            left: 10px;
            font-size: 22px;
            color: #ff5a77;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.35);
            pointer-events: none;
            z-index: 10000;
            /* ensure above UI */
            animation: heartPulse 1.6s ease-in-out infinite;
        }

        /* Body anomaly: diamond at browser top-right */
        body.anomaly-body-diamond-topright::before {
            content: '♦';
            position: fixed;
            top: 8px;
            right: 10px;
            font-size: 26px;
            color: #ff5a77;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.35);
            pointer-events: none;
            z-index: 10000;
        }

        /* Body anomaly: spade at browser bottom-right */
        body.anomaly-body-spade-bottomright::before {
            content: '♠';
            position: fixed;
            bottom: 8px;
            right: 10px;
            font-size: 26px;
            color: #444;
            text-shadow: 0 0 6px rgba(255, 255, 255, 0.2);
            pointer-events: none;
            z-index: 10000;
        }

        /* Body anomaly: club at browser bottom-left */
        body.anomaly-body-club-bottomleft::before {
            content: '♣';
            position: fixed;
            bottom: 8px;
            left: 10px;
            font-size: 26px;
            color: #444;
            text-shadow: 0 0 6px rgba(255, 255, 255, 0.2);
            pointer-events: none;
            z-index: 10000;
        }

        @keyframes heartPulse {
            from {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            to {
                transform: scale(1);
            }
        }
    </style>
</head>

<body>

    <div id="fade-overlay"></div>
    <button id="debug-toggle-btn">デバッグ表示</button>
    <div id="debug-info"></div>

    <div class="game-wrapper" id="game-wrapper">
        <div class="ceiling-light"></div>
        <div class="wall-sign"></div>
        <div class="poster"></div>
        <div class="floor"></div>
        <div class="puddle"></div>
        <div class="crack"></div>
        <h1 id="passage-title">0番通路</h1>
        <p id="description"></p>
        <div class="buttons">
            <button id="forward-button">進む</button>
            <button id="back-button">戻る</button>
        </div>
        <p id="message"></p>
    </div>

    <script>
        const wrapper = document.getElementById('game-wrapper');
        const passageTitle = document.getElementById('passage-title');
        const description = document.getElementById('description');
        const forwardButton = document.getElementById('forward-button');
        const backButton = document.getElementById('back-button');
        const message = document.getElementById('message');
        const fadeOverlay = document.getElementById('fade-overlay');
        const bodyEl = document.body;
        const debugInfo = document.getElementById('debug-info');
        const debugToggleBtn = document.getElementById('debug-toggle-btn');
        // --- For anomaly #12: buttons avoid cursor ---
        let avoidCursorActive = false;
        let buttonLogicSwapped = false;
        const buttons = () => Array.from(wrapper.querySelectorAll('.buttons button'));
        function resetButtonTransforms() {
            buttons().forEach(btn => { btn.style.transform = ''; });
        }
        function handleMouseMoveAvoid(e) {
            if (!avoidCursorActive) return;
            const mx = e.clientX;
            const my = e.clientY;
            const maxRadius = 120; // proximity radius
            const maxPush = 18;    // max px to push away
            buttons().forEach(btn => {
                const rect = btn.getBoundingClientRect();
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;
                const dx = cx - mx;
                const dy = cy - my;
                const dist = Math.hypot(dx, dy) || 1;
                if (dist < maxRadius) {
                    const scale = (1 - dist / maxRadius);
                    const mag = maxPush * scale;
                    const nx = dx / dist;
                    const ny = dy / dist;
                    const tx = nx * mag;
                    const ty = ny * mag;
                    btn.style.transform = `translate(${tx.toFixed(1)}px, ${ty.toFixed(1)}px)`;
                } else {
                    btn.style.transform = '';
                }
            });
        }
        wrapper.addEventListener('mousemove', handleMouseMoveAvoid);
        wrapper.addEventListener('mouseleave', resetButtonTransforms);
        // --- For anomaly: dim screen when cursor leaves ---
        let dimOnLeaveActive = false;
        wrapper.addEventListener('mouseenter', () => {
            if (dimOnLeaveActive) wrapper.classList.remove('is-dimmed');
        });
        wrapper.addEventListener('mouseleave', () => {
            if (dimOnLeaveActive) wrapper.classList.add('is-dimmed');
        });
        // --- For anomaly: cursor trail ---
        let cursorTrailActive = false;
        function spawnCursorTrailDot(x, y) {
            const dot = document.createElement('div');
            dot.className = 'cursor-trail-dot';
            dot.style.left = `${x}px`;
            dot.style.top = `${y}px`;
            wrapper.appendChild(dot);
            // Remove after animation
            setTimeout(() => dot.remove(), 650);
        }
        function handleMouseMoveTrail(e) {
            if (!cursorTrailActive) return;
            const rect = wrapper.getBoundingClientRect();
            spawnCursorTrailDot(e.clientX - rect.left, e.clientY - rect.top);
        }
        wrapper.addEventListener('mousemove', handleMouseMoveTrail);
        // --- For anomaly: URL bar shows "がんばれー" ---
        let urlGanbareActive = false;
        const originalURLHash = location.hash;

        let currentPassage = 0;
        let hasAnomaly = false;
        let currentAnomaly = {};
        let isFirstTurn = true;
        let isDebugMode = false;
        let shuffledAnomalies = [];
        let originalAnomalies = [];
        // Hard mode toggle from URL and pending message store
        let isHardMode = false;
        let isSoftMode = false;
        let pendingReturnMessage = '';
        let pendingProceedMessage = '';
        // Debug: anomaly selection counters
        const anomalyCountByClass = new Map();
        let anomalyPickTotal = 0;
        function incAnomalyCount(cls) {
            const key = cls || '(text-only)';
            anomalyCountByClass.set(key, (anomalyCountByClass.get(key) || 0) + 1);
            anomalyPickTotal++;
        }
        function resetAnomalyCounts() {
            anomalyCountByClass.clear();
            anomalyPickTotal = 0;
        }

        // Enable debug if the param is truthy or present
        function isDebugEnabledFromURL() {
            const params = new URLSearchParams(window.location.search);
            if (!params.has('debug')) return false;
            const raw = params.get('debug');
            if (raw === null) return true;
            const v = String(raw).toLowerCase();
            return v === '' || v === 'true' || v === '1' || v === 'on' || v === 'yes' || v === 'y' || v === 't' || v === 'ture';
        }

        // Enable hard mode if the param is truthy or present
        function isHardModeEnabledFromURL() {
            const params = new URLSearchParams(window.location.search);
            if (!params.has('hard')) return false;
            const raw = params.get('hard');
            if (raw === null) return true;
            const v = String(raw).toLowerCase();
            return v === '' || v === 'true' || v === '1' || v === 'on' || v === 'yes' || v === 'y' || v === 't' || v === 'ture';
        }

        // Enable soft mode if the param is truthy or present
        function isSoftModeEnabledFromURL() {
            const params = new URLSearchParams(window.location.search);
            if (!params.has('soft')) return false;
            const raw = params.get('soft');
            if (raw === null) return true;
            const v = String(raw).toLowerCase();
            return v === '' || v === 'true' || v === '1' || v === 'on' || v === 'yes' || v === 'y' || v === 't' || v === 'ture';
        }

        // Enable simulation mode if the param is truthy or present
        function isSimModeEnabledFromURL() {
            const params = new URLSearchParams(window.location.search);
            if (!params.has('sim')) return false;
            // simパラメータが存在すれば常にtrue（数値指定も含む）
            return true;
        }

        // Get simulation iteration count from URL
        function getSimIterationsFromURL() {
            const params = new URLSearchParams(window.location.search);
            if (!params.has('sim')) return 1000;
            const raw = params.get('sim');
            // 数値として解釈できる場合はその値を使用
            const num = parseInt(raw, 10);
            if (!isNaN(num) && num > 0) return num;
            // それ以外はデフォルト1000回
            return 1000;
        }

        const normalDescription = "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー…という音を立てて白く光っている。";

        const anomalies = [
            // テキスト異変
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー…という音を立てて白く光っている,", class: '', hint: '文末が「、」になっていた' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジーという音を立てて白く光っている。", class: '', hint: '「ジー…」の「…」がなかった' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー‥という音を立てて白く光っている。", class: '', hint: '三点リーダー「…」が二点「‥」だった' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー…という音を立てて白く光っている！", class: '', hint: '文末が「！」だった' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー…という音を立てて白く光っている?", class: '', hint: '文末が「？」だった' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー…という音を立てて白く光っている。。", class: '', hint: '句点が2つあった' },
            { desc: "あなたは簡素な通路にいる．\n壁はコンクリート打ちっぱなしだ．\n天井の蛍光灯が、ジー…という音を立てて白く光っている．", class: '', hint: '句点が全角ピリオド「．」だった' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n\n天井の蛍光灯が、ジー…という音を立てて白く光っている。", class: '', hint: '文章の間が一行空いていた' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー…という音をたてて白く光っている。", class: '', hint: '「立てて」がひらがなだった' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の螢光灯が、ジー…という音を立てて白く光っている。", class: '', hint: '「蛍光灯」の漢字が違った' },
            { desc: "あなたは簡素な通路にいる。\n璧はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー…という音を立てて白く光っている。", class: '', hint: '「壁」の漢字が違った' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー…という音を立てて白く光つている。", class: '', hint: '「光っている」の「っ」がなかった' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっ放しだ。\n天井の蛍光灯が、ジー…という音を立てて白く光っている。", class: '', hint: '「ぱなし」の表記が違った' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー…と言う音を立てて白く光っている。", class: '', hint: '「という」が漢字だった' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、シー…という音を立てて白く光っている。", class: '', hint: '擬音が「シー…」だった' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打放しだ。\n天井の蛍光灯が、ジー…という音を立てて白く光っている。", class: '', hint: '「打ちっぱなし」の表記が違った' },
            { desc: "あなたは簡素な通路に居る。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー…という音を立てて白く光っている。", class: '', hint: '「いる」が漢字だった' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー…という音を立てて白く輝いている。", class: '', hint: '「光っている」が「輝いている」だった' },
            { desc: "あなたは質素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー…という音を立てて白く光っている。", class: '', hint: '「簡素な」が「質素な」だった' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリートうちっぱなしだ。\n天井の蛍光灯が、ジー…という音を立てて白く光っている。", class: '', hint: '「打ちっぱなし」がひらがなだった' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー…というおとを立てて白く光っている。", class: '', hint: '「音」がひらがなだった' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー…という音を立てて白くひかっている。", class: '', hint: '「光っている」がひらがなだった' },
            { desc: "あなたハ簡素な通路にいる。\n壁ハコンクリート打ちっぱなしだ。\n天井ノ蛍光灯ガ、ジー…という音ヲ立てて白ク光っている。", class: '', hint: '助詞がカタカナだった' },
            { desc: "あなたはコンクリートの通路にいる。\n壁は打ちっぱなしだ。\n天井の蛍光灯が、ジー…という音を立てて白く光っている。", class: '', hint: '文章の構成が少し違った' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー…という音を立てて赤く光っている。", class: '', hint: 'テキストで「赤く」と書かれていた' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。", class: '', hint: '最後の文章がなかった' },
            { desc: "あなたは簡素な通路にいる。\n天井の蛍光灯が、ジー…という音を立てて白く光っている。", class: '', hint: '真ん中の文章がなかった' },
            { desc: "壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー…という音を立てて白く光っている。", class: '', hint: '最初の文章がなかった' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n床は濡れている。", class: '', hint: '文章の内容が一部違った' },
            { desc: "あなたは簡素な通路にいない。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、ジー…という音を立てて白く光っている。", class: '', hint: '「いる」が「いない」になっていた' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしではない。\n天井の蛍光灯が、ジー…という音を立てて白く光っている。", class: '', hint: '文章が一部否定形だった' },
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天井の蛍光灯が、音もなく白く光っている。", class: '', hint: '「音もなく」と書かれていた' },
            { desc: normalDescription + "\n背後に気配がする。", class: '', hint: '文末に一文追加されていた' },

            // CSS異変
            { desc: normalDescription, class: 'anomaly-title-weight', hint: '通路番号の太さが違った' },
            { desc: normalDescription, class: 'anomaly-light-red', hint: '天井の照明が赤かった' },
            { desc: normalDescription, class: 'anomaly-light-flicker', hint: '天井の照明が点滅していた' },
            { desc: normalDescription, class: 'anomaly-light-off', hint: '天井の照明が消えていた' },
            { desc: normalDescription, class: 'anomaly-light-green', hint: '天井の照明が緑色だった' },
            { desc: normalDescription, class: 'anomaly-light-narrow', hint: '天井の照明が細かった' },
            { desc: normalDescription, class: 'anomaly-font-creepy', hint: '説明文のフォントが違った' },
            { desc: normalDescription, class: 'anomaly-shake', hint: '画面が揺れていた' },
            { desc: normalDescription, class: 'anomaly-text-color-strong', hint: '説明文の色がピンクだった' },
            { desc: normalDescription, class: 'anomaly-letter-spacing', hint: '説明文の文字間隔が広かった' },
            { desc: normalDescription, class: 'anomaly-title-color-strong', hint: '通路番号の色がオレンジだった' },
            { desc: normalDescription, class: 'anomaly-sign-crooked', hint: '非常口が傾いていた' },
            { desc: normalDescription, class: 'anomaly-sign-garbled', hint: '非常口のフォントが違った' },
            { desc: normalDescription, class: 'anomaly-sign-shadow', hint: '非常口の影が赤かった' },
            { desc: normalDescription, class: 'anomaly-sign-blue', hint: '非常口の色が青かった' },
            { desc: normalDescription, class: 'anomaly-poster-missing', hint: '左のポスターがなかった' },
            { desc: normalDescription, class: 'anomaly-sign-text-changed', hint: '非常口の文字が「入口」だった' },
            { desc: normalDescription, class: 'anomaly-sign-text-mirrored', hint: '非常口の文字が鏡文字だった' },
            { desc: normalDescription, class: 'anomaly-sign-dashed', hint: '非常口の枠線が点線だった' },
            { desc: normalDescription, class: 'anomaly-sign-text-yellow', hint: '非常口の文字が黄色だった' },
            { desc: normalDescription, class: 'anomaly-sign-open', hint: '非常口のドアが開いていた' },
            { desc: normalDescription, class: 'anomaly-sign-peeking', hint: '非常口の上から誰かが見ていた' },
            { desc: normalDescription, class: 'anomaly-text-align-justify', hint: '説明文が両端揃えだった' },
            { desc: normalDescription, class: 'anomaly-border-radius', hint: '全体の枠が丸まっていた' },
            { desc: normalDescription, class: 'anomaly-buttons-swapped', hint: '進む/戻るボタンの位置が逆だった' },
            { desc: normalDescription, class: 'anomaly-buttons-black-text', hint: 'ボタンの文字が黒かった' },
            { desc: normalDescription, class: 'anomaly-puddle', hint: '床に水たまりがあった' },
            { desc: normalDescription, class: 'anomaly-puddle-green', hint: '床の水たまりが緑色だった' },
            { desc: normalDescription, class: 'anomaly-crack', hint: '壁に亀裂があった' },
            { desc: normalDescription, class: 'anomaly-crack-red', hint: '壁の亀裂が赤かった' },
            { desc: normalDescription, class: 'anomaly-border-color-strong', hint: '全体の枠線の色が紫だった' },
            { desc: normalDescription, class: 'anomaly-border-color-green', hint: '全体の枠線の色が緑だった' },
            { desc: normalDescription, class: 'anomaly-border-color-blue', hint: '全体の枠線の色が青だった' },
            { desc: normalDescription, class: 'anomaly-bg-strong', hint: '背景の色が濃い青だった' },
            { desc: normalDescription, class: 'anomaly-wrapper-bg-strong', hint: 'ゲーム画面の背景が濃い赤だった' },
            { desc: normalDescription, class: 'anomaly-floor-yellow', hint: '床の模様が黄色だった' },
            { desc: normalDescription, class: 'anomaly-floor-red', hint: '床の模様が赤かった' },
            { desc: normalDescription, class: 'anomaly-floor-blue', hint: '床の模様が青かった' },
            { desc: normalDescription, class: 'anomaly-poster-upside-down', hint: '左のポスターが逆さまだった' },
            { desc: normalDescription, class: 'anomaly-poster-text-garbled', hint: '左のポスターの文字が化けていた' },
            { desc: normalDescription, class: 'anomaly-poster-missing', hint: '左のポスターがなかった' },
            { desc: normalDescription, class: 'anomaly-poster-text-changed', hint: 'ポスターの文字が「危険」だった' },
            { desc: normalDescription, class: 'anomaly-poster-text-mirrored', hint: '左のポスターの文字が鏡文字だった' },
            { desc: normalDescription, class: 'anomaly-poster-color-changed', hint: 'ポスターの色が水色だった' },
            { desc: normalDescription, class: 'anomaly-poster-bigger', hint: '左のポスターが大きくなっていた' },
            { desc: normalDescription, class: 'anomaly-poster-smaller', hint: '左のポスターが小さくなっていた' },
            { desc: normalDescription, class: 'anomaly-poster-eye', hint: '左のポスターに目玉が表示されていた' },
            { desc: normalDescription, class: 'anomaly-text-upside-down', hint: '説明文が逆さまだった' },
            { desc: normalDescription, class: 'anomaly-text-mirrored', hint: '説明文が鏡文字だった' },
            { desc: normalDescription, class: 'anomaly-floor-angle-changed', hint: '床の模様の角度が逆だった' },
            { desc: normalDescription, class: 'anomaly-floor-steeper-angle', hint: '床の斜線の角度が急だった' },
            { desc: normalDescription, class: 'anomaly-floor-wider-stripes', hint: '床の模様の線の幅が均一ではなかった' },
            { desc: normalDescription, class: 'anomaly-puddle-red', hint: '床の水たまりが赤かった' },
            { desc: normalDescription, class: 'anomaly-title-shadow-green', hint: '通路番号の影が緑だった' },
            { desc: normalDescription, class: 'anomaly-buttons-glow', hint: 'ボタンが光っていた' },
            { desc: normalDescription, class: 'anomaly-wrapper-rotated', hint: '全体が僅かに傾いていた' },
            { desc: normalDescription, class: 'anomaly-message-border', hint: 'メッセージ欄に枠があった' },
            { desc: normalDescription, class: 'anomaly-buttons-square', hint: 'ボタンが四角かった' },
            { desc: normalDescription, class: 'anomaly-body-grayscale', hint: '全体が白黒だった' },
            { desc: normalDescription, class: 'anomaly-body-sepia', hint: '全体がセピア色だった' },
            { desc: normalDescription, class: 'anomaly-body-invert', hint: '全体の色が反転していた' },
            { desc: normalDescription, class: 'anomaly-body-hue-rotate', hint: '全体の色相が回転していた' },
            { desc: normalDescription, class: 'anomaly-body-blur', hint: '全体がぼやけていた' },
            { desc: normalDescription, class: 'anomaly-body-contrast', hint: '全体のコントラストが高かった' },
            { desc: normalDescription, class: 'anomaly-body-silhouette', hint: '背景に人影が表示されていた' },

            // --- Added anomalies (request) ---
            // 1. 「天井」が「天丼」
            { desc: "あなたは簡素な通路にいる。\n壁はコンクリート打ちっぱなしだ。\n天丼の蛍光灯が、ジー…という音を立てて白く光っている。", class: '', hint: '「天井」が「天丼」だった' },
            // 2. 進む->進め
            { desc: normalDescription, class: 'anomaly-forward-imperative', hint: 'ボタンの「進む」が「進め」だった' },
            // 3. 戻る->戻れ
            { desc: normalDescription, class: 'anomaly-back-imperative', hint: 'ボタンの「戻る」が「戻れ」だった' },
            // 4. 右下にパンティー
            { desc: normalDescription, class: 'anomaly-panties-br', hint: '右下にパンティーが落ちていた' },
            // 5. 左下にトランクス
            { desc: normalDescription, class: 'anomaly-trunks-bl', hint: '左下にトランクスが落ちていた' },
            // 6. 安全第一→安全弟一
            { desc: normalDescription, class: 'anomaly-poster-safety-brother', hint: 'ポスターの「安全第一」が「安全弟一」だった' },
            // ポスターの「安全第一」が「安全安心」だった
            { desc: normalDescription, class: 'anomaly-poster-safety-anshin', hint: 'ポスターの「安全第一」が「安全安心」だった' },
            // 8. 非常口が高い
            { desc: normalDescription, class: 'anomaly-sign-higher', hint: '非常口の位置が少し高かった' },
            // 8b. 非常口が低い
            { desc: normalDescription, class: 'anomaly-sign-lower', hint: '非常口の位置が少し低かった' },
            // 9. ポスターが高い
            { desc: normalDescription, class: 'anomaly-poster-higher', hint: 'ポスターの位置が少し高かった' },
            // 9b. ポスターが低い
            { desc: normalDescription, class: 'anomaly-poster-lower', hint: 'ポスターの位置が少し低かった' },
            // 10. 「〜番通路」の表示位置が少し低い
            { desc: normalDescription, class: 'anomaly-passage-title-lower', hint: '「〜番通路」の表示位置が少し低かった' },
            // 11. 天井ライトのブラー効果が少し大きい
            { desc: normalDescription, class: 'anomaly-light-blur-stronger', hint: '天井ライトの光線が強かった' },
            // 12. カーソルを近づけるとボタンが逃げる
            { desc: normalDescription, class: 'anomaly-buttons-avoid-cursor', hint: 'カーソルに反発してボタンが少し逃げた' },
            // 13. カーソルの色が薄くなる
            { desc: normalDescription, class: 'anomaly-cursor-faint', hint: 'カーソルの色が薄くなっていた' },
            // 14. 画面外にカーソルで暗くなる
            { desc: normalDescription, class: 'anomaly-dim-on-leave', hint: 'ゲーム画面外にカーソルで画面が暗くなった' },
            // 15. カーソル移動で薄い軌跡が残る
            { desc: normalDescription, class: 'anomaly-cursor-trail', hint: 'カーソルの移動に薄い軌跡が残った' },
            // 16. URL表示欄に「がんばれー」
            { desc: normalDescription, class: 'anomaly-url-ganbare', hint: 'URLの表示欄に「がんばれー」と表示された' },
            // 17. ブラウザ左上にハート
            { desc: normalDescription, class: 'anomaly-body-heart-topleft', hint: 'ブラウザの左上にハートが表示された' },
            { desc: normalDescription, class: 'anomaly-body-diamond-topright', hint: 'ブラウザの右上にダイヤが表示されていた' },
            { desc: normalDescription, class: 'anomaly-body-spade-bottomright', hint: 'ブラウザの右下にスペードが表示されていた' },
            { desc: normalDescription, class: 'anomaly-body-club-bottomleft', hint: 'ブラウザの左下にクラブが表示されていた' },
            { desc: normalDescription, class: 'anomaly-floor-hand', hint: '床から手が生えていた' },
            { desc: normalDescription, class: 'anomaly-floor-shadow-hand', hint: '床から影の手が湧き上がっていた' },
            { desc: normalDescription, class: 'anomaly-floor-bamboo', hint: '床からたけのこが生えていた' },
            { desc: normalDescription, class: 'anomaly-floor-mushroom', hint: '床からきのこが生えていた' },
            { desc: normalDescription, class: 'anomaly-floor-grass', hint: '床から草が生えていた' },
            { desc: normalDescription, class: 'anomaly-floor-w', hint: '床からWの文字が生えていた' },
            { desc: normalDescription, class: 'anomaly-buttons-logic-swapped', hint: '進むボタンと戻るボタンの文字が逆だった' }
        ];

        // Use crypto-backed randomness to avoid repetitive patterns across reloads
        function randomFloat() {
            try {
                if (window.crypto && window.crypto.getRandomValues) {
                    const u32 = new Uint32Array(1);
                    window.crypto.getRandomValues(u32);
                    // 0 <= x < 1
                    return u32[0] / 4294967296; // 2^32
                }
            } catch (_) { /* fallback below */ }
            return Math.random();
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(randomFloat() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function getNextAnomaly() {
            if (shuffledAnomalies.length === 0) {
                shuffledAnomalies = [...anomalies];
                shuffleArray(shuffledAnomalies);
            }
            return shuffledAnomalies.pop();
        }

        // NOTE: Debug UI is initialized in initDebugMode() to avoid duplication.

        function initDebugMode() {
            if (isDebugEnabledFromURL()) {
                isDebugMode = true;
                debugToggleBtn.style.display = 'block';
                debugInfo.style.display = 'block';
                debugInfo.classList.add('active');

                // トグルボタンのクリックイベント
                debugToggleBtn.addEventListener('click', () => {
                    if (debugInfo.classList.contains('hidden')) {
                        debugInfo.classList.remove('hidden');
                        debugInfo.style.display = 'block';
                        debugToggleBtn.textContent = 'デバッグ非表示';
                    } else {
                        debugInfo.classList.add('hidden');
                        debugInfo.style.display = 'none';
                        debugToggleBtn.textContent = 'デバッグ表示';
                    }
                });

                console.log('Initializing debug mode...');

                // デバッグモード用に元の配列をコピーして保存
                originalAnomalies = JSON.parse(JSON.stringify(anomalies));

                // すでに初期化済みなら再初期化を避ける
                if (debugInfo.querySelector('#anomaly-selector')) {
                    updateDebugInfo();
                    return;
                }

                const selector = document.createElement('select');
                selector.id = 'anomaly-selector';
                selector.innerHTML = '<option value="-1">異変なし</option>';
                // 選択した時点で即適用
                selector.addEventListener('change', () => {
                    const selectedIndex = parseInt(selector.value, 10);
                    forceSetAnomaly(selectedIndex);
                });

                // 元の配列をソート用に準備
                const anomaliesWithIndex = originalAnomalies.map((anomaly, index) => ({
                    hint: anomaly.hint,
                    originalIndex: index,
                    anomaly: anomaly
                }));

                console.log('Total anomalies before sort:', anomaliesWithIndex.length);

                // ヒントの内容でソート
                anomaliesWithIndex.sort((a, b) => a.hint.localeCompare(b.hint, 'ja'));

                // option要素を作成（出現数付き）
                function updateSelectorOptions() {
                    // 既存のオプション（最初の「異変なし」以外）を削除
                    while (selector.options.length > 1) {
                        selector.remove(1);
                    }

                    // 各異変の出現数を取得して、オプションを再作成
                    anomaliesWithIndex.forEach((item, sortedIndex) => {
                        const option = document.createElement('option');
                        option.value = item.originalIndex;
                        const cls = item.anomaly.class || '(text-only)';
                        const count = anomalyCountByClass.get(cls) || 0;
                        option.textContent = `[${item.originalIndex}] ${item.hint} (${count}回)`;
                        selector.appendChild(option);
                    });
                }

                // 初回作成
                updateSelectorOptions();

                // updateDebugInfo実行時にドロップダウンも更新するため、グローバルに参照を保存
                window.updateSelectorOptions = updateSelectorOptions;

                // 脱出成功スクリーン表示ボタン
                const successBtn = document.createElement('button');
                successBtn.id = 'show-success-btn';
                successBtn.textContent = '脱出成功を表示';
                successBtn.onclick = () => {
                    currentPassage = 8;
                    hasAnomaly = false;
                    clearGame();
                    fadeOverlay.classList.remove('is-active');
                };

                // デバッグ：異変カウントのリセットボタン
                const resetCountBtn = document.createElement('button');
                resetCountBtn.id = 'reset-counts-btn';
                resetCountBtn.textContent = '異変カウントをリセット';
                resetCountBtn.onclick = () => { resetAnomalyCounts(); updateDebugInfo(); };

                debugInfo.innerHTML = '<h3>--- DEBUG MODE ---</h3><p>Loading...</p>';
                debugInfo.appendChild(selector);
                debugInfo.appendChild(successBtn);
                debugInfo.appendChild(resetCountBtn);

                console.log('Debug mode initialized');
            }
        }

        function updateDebugInfo() {
            if (!isDebugMode) return;

            const successMessage = wrapper.querySelector('.success-message');
            if (successMessage) {
                debugInfo.innerHTML = `
                <h3>--- DEBUG MODE ---</h3>
                <b>GAME STATE:</b> CLEARED<br>
                <b>Final Passage:</b> ${currentPassage}
            `;
                return;
            }

            const hintText = hasAnomaly ? currentAnomaly.hint : 'なし';
            const debugContent = `
            <h3>--- DEBUG MODE ---</h3>
            <b>Passage:</b> ${currentPassage}<br>
            <b>Anomaly Active:</b> ${hasAnomaly}<br>
            <b>Description:</b> ${hintText}<br>
            <b>Class:</b> ${currentAnomaly.class || 'なし'}<br>
            <hr>
            <b>Picks Total:</b> ${anomalyPickTotal} / <b>Distinct Seen:</b> ${anomalyCountByClass.size}<br>
        `;

            const selector = debugInfo.querySelector('#anomaly-selector');
            const successBtn = debugInfo.querySelector('#show-success-btn');
            const resetCountBtn = debugInfo.querySelector('#reset-counts-btn');
            debugInfo.innerHTML = debugContent;
            if (selector) debugInfo.appendChild(selector);
            if (successBtn) debugInfo.appendChild(successBtn);
            if (resetCountBtn) debugInfo.appendChild(resetCountBtn);

            // ドロップダウンの出現数表示を更新
            if (window.updateSelectorOptions) {
                window.updateSelectorOptions();
            }
        }

        function resetVisuals() {
            // 異変の解除時にトランジションで動きが出ないよう一時的に抑止
            wrapper.classList.add('no-transition');
            bodyEl.classList.add('no-transition-filter');
            if (currentAnomaly.class) {
                wrapper.classList.remove(currentAnomaly.class);
                bodyEl.classList.remove(currentAnomaly.class);
            }

            description.style.color = '';
            passageTitle.style.color = '';
            wrapper.style.borderColor = '';
            wrapper.style.backgroundColor = '';
            wrapper.style.transform = '';
            wrapper.style.boxShadow = '';
            bodyEl.style.backgroundColor = '';
            bodyEl.style.filter = '';
            forwardButton.style.color = '';
            backButton.style.color = '';
            message.style.border = '';
            // reset button drift (for avoid-cursor anomaly)
            avoidCursorActive = false;
            resetButtonTransforms();
            // reset logic swap state
            buttonLogicSwapped = false;
            // reset dim-on-leave state
            dimOnLeaveActive = false;
            wrapper.classList.remove('is-dimmed');
            // reset cursor trail
            cursorTrailActive = false;
            wrapper.querySelectorAll('.cursor-trail-dot').forEach(el => el.remove());
            // reset URL bar text if we changed it
            if (urlGanbareActive) {
                history.replaceState(null, '', location.pathname + location.search + originalURLHash);
                urlGanbareActive = false;
            }
            // 次フレームで抑止フラグを解除
            requestAnimationFrame(() => {
                // reflow を挟んで確実にスタイルを確定
                void wrapper.offsetHeight;
                wrapper.classList.remove('no-transition');
                bodyEl.classList.remove('no-transition-filter');
            });
        }

        function applyAnomaly(anomaly) {
            currentAnomaly = anomaly;
            description.innerHTML = currentAnomaly.desc;
            // 異変の適用時もトランジションで動きが出ないよう一時的に抑止
            wrapper.classList.add('no-transition');
            bodyEl.classList.add('no-transition-filter');
            if (currentAnomaly.class) {
                if (currentAnomaly.class.startsWith('anomaly-body-')) {
                    bodyEl.classList.add(currentAnomaly.class);
                } else {
                    wrapper.classList.add(currentAnomaly.class);
                }
            }
            // Enable/disable logic swap based on anomaly
            buttonLogicSwapped = currentAnomaly.class === 'anomaly-buttons-logic-swapped';
            // Debug: record the pick when an anomaly is active
            if (hasAnomaly) {
                incAnomalyCount(currentAnomaly.class);
            }
            // Enable/disable cursor-avoid behavior dynamically
            avoidCursorActive = currentAnomaly.class === 'anomaly-buttons-avoid-cursor';
            if (!avoidCursorActive) resetButtonTransforms();
            // Enable dim-on-leave behavior dynamically
            dimOnLeaveActive = currentAnomaly.class === 'anomaly-dim-on-leave';
            if (!dimOnLeaveActive) wrapper.classList.remove('is-dimmed');
            // Enable cursor trail behavior dynamically
            cursorTrailActive = currentAnomaly.class === 'anomaly-cursor-trail';
            if (!cursorTrailActive) wrapper.querySelectorAll('.cursor-trail-dot').forEach(el => el.remove());
            // Enable URL bar change dynamically (use hash to avoid navigation)
            if (currentAnomaly.class === 'anomaly-url-ganbare') {
                urlGanbareActive = true;
                history.replaceState(null, '', location.pathname + location.search + '#がんばれー');
            } else if (urlGanbareActive) {
                history.replaceState(null, '', location.pathname + location.search + originalURLHash);
                urlGanbareActive = false;
            }
            // 次フレームで抑止フラグを解除（アニメーション系の異変はCSSのanimationで動くため影響なし）
            requestAnimationFrame(() => {
                void wrapper.offsetHeight;
                wrapper.classList.remove('no-transition');
                bodyEl.classList.remove('no-transition-filter');
            });
        }

        function forceSetAnomaly(index) {
            resetVisuals();
            if (index === -1) {
                hasAnomaly = false;
                currentAnomaly = {};
                description.innerHTML = normalDescription;
            } else {
                hasAnomaly = true;
                const anomaly = anomalies[index];
                applyAnomaly(anomaly);
            }
            updateDebugInfo();
        }

        function setupNewPassage() {
            passageTitle.textContent = `${currentPassage >= 8 ? 8 : currentPassage}番通路`;

            resetVisuals();

            currentAnomaly = {};
            // Clear transient message so '...' does not remain when nothing to show
            message.textContent = '';

            if (isFirstTurn) {
                hasAnomaly = false;
                isFirstTurn = false;
            } else if (randomFloat() < 0.70) {
                hasAnomaly = true;
            } else {
                hasAnomaly = false;
            }

            if (hasAnomaly) {
                applyAnomaly(getNextAnomaly());
            } else {
                description.innerHTML = normalDescription;
            }
            updateDebugInfo();

            // In normal mode, if a pending message exists when returning to 0, show the cause.
            if (!isHardMode && currentPassage === 0 && pendingReturnMessage) {
                message.textContent = pendingReturnMessage;
                pendingReturnMessage = '';
            }

            // In soft mode, after a correct detection on previous turn, show the anomaly content
            if (isSoftMode && currentPassage > 0 && pendingProceedMessage) {
                message.textContent = pendingProceedMessage;
                pendingProceedMessage = '';
            }
        }

        function processTurn(decision) {
            if (currentPassage >= 8 && !hasAnomaly && decision === false) {
                forwardButton.disabled = true;
                backButton.disabled = true;
                fadeOverlay.classList.add('is-active');
                setTimeout(() => {
                    clearGame();
                    // Reveal the success screen after fade
                    fadeOverlay.classList.remove('is-active');
                }, 1000);
                return;
            }

            const isCorrect = decision === hasAnomaly;

            forwardButton.disabled = true;
            backButton.disabled = true;
            fadeOverlay.classList.add('is-active');

            setTimeout(() => {
                if (isCorrect) {
                    // In soft mode, if an anomaly was correctly detected, carry over its content
                    if (isSoftMode && hasAnomaly && currentAnomaly && currentAnomaly.hint) {
                        pendingProceedMessage = `異変: ${currentAnomaly.hint}`;
                    }
                    message.textContent = '...';
                    if (currentPassage < 8) {
                        currentPassage++;
                    }
                } else {
                    const msg = hasAnomaly
                        ? `異変を見逃しました。(内容: ${currentAnomaly.hint})`
                        : "異変はありませんでした。";
                    // In hard mode, show nothing when returning to 0.
                    // In normal mode, defer the cause message to display on the 0 passage.
                    pendingReturnMessage = isHardMode ? '' : `${msg} 0番通路に戻ります。`;
                    currentPassage = 0;
                    isFirstTurn = true;
                    shuffledAnomalies = [];
                }

                setupNewPassage();

                fadeOverlay.classList.remove('is-active');

                setTimeout(() => {
                    const successMessage = wrapper.querySelector('.success-message');
                    if (!successMessage) {
                        forwardButton.disabled = false;
                        backButton.disabled = false;
                    }
                }, 1000);

            }, 1000);
        }

        function clearGame() {
            wrapper.innerHTML = `
            <div class="exit-container">
                <div class="exit-light"></div>
                <div class="exit-floor"></div>
                <div class="stairs">
                    <div class="step"></div>
                    <div class="step"></div>
                    <div class="step"></div>
                    <div class="step"></div>
                    <div class="step"></div>
                </div>
                <div class="success-message">脱出成功！</div>
            </div>
            <style>
                .exit-container {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: flex-end;
                    height: 300px;
                    position: relative;
                    background: radial-gradient(circle at 50% -40px, rgba(0,0,0,0.2) 0%, rgba(0,0,0,0.6) 55%, rgba(0,0,0,0.85) 100%);
                    overflow: hidden;
                }
                .exit-container::before{
                    content: '';
                    position: absolute;
                    inset: -60px;
                    background: radial-gradient(circle at 50% -40px, rgba(0,0,0,0) 28%, rgba(0,0,0,0.55) 62%, rgba(0,0,0,0.9) 95%);
                    z-index: 2; /* darken surroundings */
                    pointer-events: none;
                }
                .exit-light {
                    position: absolute;
                    top: -50px;
                    width: 400%;
                    height: 260px;
                    background:
                        radial-gradient(circle at 50% 10%, rgba(255,255,255,1) 0%, rgba(255,255,255,0.85) 14%, rgba(255,255,180,0.7) 26%, rgba(255,255,200,0.25) 46%, rgba(255,255,220,0.05) 70%, rgba(255,255,220,0) 80%),
                        radial-gradient(circle at 50% 10%, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0) 35%);
                    filter: blur(6px) brightness(1.25);
                    animation: glowPulse 2.2s ease-in-out infinite;
                    z-index: 1; /* behind overlay */
                }
                /* Foreground floor plane */
                .exit-floor {
                    position: absolute;
                    left: 50%;
                    bottom: -10px;
                    transform: translateX(-50%) perspective(700px) rotateX(58deg);
                    width: 320%;
                    height: 160px;
                    background:
                        linear-gradient(to bottom, rgba(255,255,255,0.95), rgba(238,238,238,0.9)),
                        repeating-linear-gradient(45deg, rgba(245,245,245,0.9) 0px, rgba(245,245,245,0.9) 10px, rgba(232,232,232,0.9) 10px, rgba(232,232,232,0.9) 20px);
                    box-shadow: 0 -8px 30px rgba(255,255,220,0.6) inset, 0 0 30px rgba(255,255,200,0.25);
                    z-index: 3; /* same layer as stairs, will render under by DOM order */
                }
                .stairs {
                    width: 150px;
                    height: 150px;
                    position: relative;
                    perspective: 400px;
                    z-index: 3; /* above vignette */
                    overflow: visible;
                }
                /* Soft glow spilling onto the steps */
                .stairs::before {
                    content: '';
                    position: absolute;
                    left: 50%;
                    top: -10px;
                    transform: translateX(-50%);
                    width: 200%;
                    height: 180%;
                    background: radial-gradient(ellipse at 50% -20px,
                        rgba(255,255,240,0.85) 0%,
                        rgba(255,255,210,0.55) 25%,
                        rgba(255,255,190,0.25) 48%,
                        rgba(255,255,180,0) 70%);
                    filter: blur(10px);
                    pointer-events: none;
                    z-index: 4;
                }
                /* Light rays across the stairs */
                .stairs::after {
                    content: '';
                    position: absolute;
                    left: 50%;
                    top: -20px;
                    transform: translateX(-50%) rotate(-8deg);
                    width: 260%;
                    height: 200%;
                    background:
                        repeating-linear-gradient(
                            to bottom,
                            rgba(255,255,220,0.35) 0px,
                            rgba(255,255,220,0.35) 6px,
                            rgba(255,255,220,0.0) 22px,
                            rgba(255,255,220,0.0) 32px
                        );
                    opacity: 0.8;
                    filter: blur(8px);
                    pointer-events: none;
                    z-index: 4;
                }
                .step {
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    width: 100%;
                    height: 30px;
                    background: #f0f0f0;
                    border-top: 2px solid #ffffff;
                    transform-origin: bottom center;
                    box-shadow: inset 0 8px 18px rgba(255,255,240,0.25);
                }
                .step:nth-child(1) { transform: translateZ(0px) translateY(0px); }
                .step:nth-child(2) { transform: translateZ(-30px) translateY(-30px); }
                .step:nth-child(3) { transform: translateZ(-60px) translateY(-60px); }
                .step:nth-child(4) { transform: translateZ(-90px) translateY(-90px); }
                .step:nth-child(5) { transform: translateZ(-120px) translateY(-120px); }
                .success-message {
                    margin-top: 20px;
                    color: #ffffff;
                    font-size: 2.2em;
                    font-weight: 700;
                    -webkit-text-stroke: 1px rgba(0,0,0,0.55);
                    text-shadow:
                        0 1px 2px rgba(0,0,0,0.85),
                        0 2px 6px rgba(0,0,0,0.6),
                        0 0 8px rgba(255,255,200,0.85),
                        0 0 18px rgba(255,255,140,0.55);
                    animation: pulse 1.5s infinite alternate;
                    z-index: 5;
                }
                @keyframes pulse{from{transform:scale(1)}to{transform:scale(1.05)}}
                @keyframes glowPulse{0%{filter: blur(6px) brightness(1.15)}50%{filter: blur(7px) brightness(1.35)}100%{filter: blur(6px) brightness(1.15)}}
            </style>
        `;
            updateDebugInfo();
        }

        // When the logic-swapped anomaly is active, swap the decision mapping
        forwardButton.addEventListener('click', () => { processTurn(buttonLogicSwapped ? true : false); });
        backButton.addEventListener('click', () => { processTurn(buttonLogicSwapped ? false : true); });

        // シミュレーションモードの実装
        function runSimulation() {
            const iterations = getSimIterationsFromURL();

            console.log('=== シミュレーションモード開始 ===');
            console.log(`異変総数: ${anomalies.length}`);
            console.log(`繰り返し回数: ${iterations}`);
            console.log('');

            // 各異変の出現回数をカウント
            const pickCounts = new Map();

            for (let i = 0; i < iterations; i++) {
                console.log(`--- 第${i + 1}回シャッフル ---`);

                // 実際のコードと同じ方法でシャッフル
                const testArray = [...anomalies];
                shuffleArray(testArray);

                // 末尾10個を取得
                const last10 = testArray.slice(-10);

                console.log('末尾10個:');
                last10.forEach((anomaly, idx) => {
                    const key = anomaly.hint;
                    const position = testArray.length - 10 + idx;
                    console.log(`  [${position}] ${key}`);

                    // カウント
                    pickCounts.set(key, (pickCounts.get(key) || 0) + 1);
                });
                console.log('');
            }

            // 統計情報を表示
            console.log('=== 統計結果 ===');
            console.log(`総シャッフル回数: ${iterations}`);
            console.log(`末尾10個 × ${iterations}回 = ${iterations * 10}回の選択機会`);
            console.log('');

            // 出現回数でソート
            const sortedCounts = Array.from(pickCounts.entries())
                .sort((a, b) => b[1] - a[1]);

            console.log('各異変の出現回数（降順）:');
            sortedCounts.forEach(([hint, count]) => {
                const percentage = ((count / (iterations * 10)) * 100).toFixed(2);
                console.log(`  ${count}回 (${percentage}%): ${hint}`);
            });
            console.log('');

            // 理論値との比較
            const expectedCount = (iterations * 10) / anomalies.length;
            const expectedPercentage = ((10 / anomalies.length) * 100).toFixed(2);
            console.log(`理論上の期待値: ${expectedCount.toFixed(2)}回 (${expectedPercentage}%)`);
            console.log('');

            // 偏りの検出
            const maxCount = sortedCounts[0][1];
            const minCount = sortedCounts[sortedCounts.length - 1][1];
            const variance = maxCount - minCount;
            console.log(`最大出現回数: ${maxCount}回`);
            console.log(`最小出現回数: ${minCount}回`);
            console.log(`分散: ${variance}回`);
            console.log('');

            // 出現回数0の異変
            const neverPicked = anomalies.filter(a => !pickCounts.has(a.hint));
            if (neverPicked.length > 0) {
                console.log(`出現しなかった異変: ${neverPicked.length}個`);
                neverPicked.forEach(a => {
                    console.log(`  - ${a.hint}`);
                });
            } else {
                console.log('全ての異変が少なくとも1回は出現しました');
            }

            console.log('');
            console.log('=== シミュレーション完了 ===');

            // 画面に結果を表示
            wrapper.innerHTML = `
                <div style="padding: 20px; text-align: left; font-family: monospace; font-size: 14px; max-height: 80vh; overflow-y: auto;">
                    <h2 style="text-align: center; color: #e53935;">シミュレーション完了</h2>
                    <p><strong>総シャッフル回数:</strong> ${iterations}回</p>
                    <p><strong>総選択機会:</strong> ${iterations * 10}回</p>
                    <p><strong>理論上の期待値:</strong> ${expectedCount.toFixed(2)}回 (${expectedPercentage}%)</p>
                    <p><strong>最大出現回数:</strong> ${maxCount}回 (最頻: ${sortedCounts[0][0]})</p>
                    <p><strong>最小出現回数:</strong> ${minCount}回</p>
                    <p><strong>分散:</strong> ${variance}回</p>
                    <p><strong>出現しなかった異変:</strong> ${neverPicked.length}個</p>
                    <hr>
                    <p style="color: #ffd700;">詳細はブラウザのコンソール（F12）を確認してください。</p>
                </div>
            `;
        }

        initDebugMode();
        // Initialize hard/soft mode from URL
        isHardMode = isHardModeEnabledFromURL();
        isSoftMode = isSoftModeEnabledFromURL();

        // シミュレーションモードチェック
        if (isSimModeEnabledFromURL()) {
            runSimulation();
        } else {
            // NOTE: Do not shuffle the master `anomalies` array.
            // Random selection uses `shuffledAnomalies` built from a copy in getNextAnomaly().
            // Shuffling here breaks debug dropdown indices.
            setupNewPassage();
        }
    </script>

</body>

</html>